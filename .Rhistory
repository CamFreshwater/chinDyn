survDat = byDatTrim) %>%
inner_join(byDatTrim %>% select(stock, smoltType, adultRunTiming),
by = "stock") %>%
distinct()
#No coherent patterns associated with adult run timing
ggplot(rotZ, aes(x = stock, y = loading, fill = smoltType)) +
geom_col() +
theme_sleekX(axisSize = 9, legendSize = 0.7) +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
facet_wrap(~trend)
listOfPackages <- c("here", "MARSS", "tidyverse", "ggplot2", "parallel",
"doParallel", "foreach", "tictoc")
lapply(listOfPackages, require, character.only = TRUE)
#helper functions to fit and post-process DFA
source(here("R/functions/dfaFunctions.R"))
byDat <- read.csv(here("data/salmonData/CLEANcwtInd_age2SR_BY.csv"),
stringsAsFactors = FALSE)
#focus on subset of BC pops for initial analyses
byDatTrim <- byDat %>%
filter(region %in% c("LFR", "MFR", "UFR", "ECVI", "SPGSD", "NPGSD"),
BY > 1984) %>%
group_by(stock) %>%
mutate(survZ = as.numeric(scale(surv))) %>%
ungroup(stock) %>%
arrange(region) %>%
mutate(stock = factor(stock, unique(stock))) %>%
select(-stockName, -jurisdiction, -lat, -long)
head(byDat)
#focus on subset of BC pops for initial analyses
byDatTrim <- byDat %>%
dplyr::filter(region %in% c("LFR", "MFR", "UFR", "ECVI", "SPGSD", "NPGSD"),
BY > 1984) %>%
group_by(stock) %>%
mutate(survZ = as.numeric(scale(surv))) %>%
ungroup(stock) %>%
arrange(region) %>%
mutate(stock = factor(stock, unique(stock))) %>%
select(-stockName, -jurisdiction, -lat, -long)
listOfPackages <- c("here", "MARSS", "tidyverse", "ggplot2", "parallel",
"doParallel", "foreach", "tictoc")
lapply(listOfPackages, require, character.only = TRUE)
#helper functions to fit and post-process DFA
source(here("R/functions/dfaFunctions.R"))
byDat <- read.csv(here("data/salmonData/CLEANcwtInd_age2SR_BY.csv"),
stringsAsFactors = FALSE)
#focus on subset of BC pops for initial analyses
byDatTrim <- byDat %>%
dplyr::filter(region %in% c("LFR", "MFR", "UFR", "ECVI", "SPGSD", "NPGSD"),
BY > 1984) %>%
group_by(stock) %>%
mutate(survZ = as.numeric(scale(surv))) %>%
ungroup(stock) %>%
arrange(region) %>%
mutate(stock = factor(stock, unique(stock))) %>%
select(-stockName, -jurisdiction, -lat, -long)
require("tidyverse")
install.packages("tidyverse")
require("tidyverse")
#focus on subset of BC pops for initial analyses
byDatTrim <- byDat %>%
dplyr::filter(region %in% c("LFR", "MFR", "UFR", "ECVI", "SPGSD", "NPGSD"),
BY > 1984) %>%
group_by(stock) %>%
mutate(survZ = as.numeric(scale(surv))) %>%
ungroup(stock) %>%
arrange(region) %>%
mutate(stock = factor(stock, unique(stock))) %>%
select(-stockName, -jurisdiction, -lat, -long)
require("tidyverse")
install.packages("colorspace")
#focus on subset of BC pops for initial analyses
byDatTrim <- byDat %>%
dplyr::filter(region %in% c("LFR", "MFR", "UFR", "ECVI", "SPGSD", "NPGSD"),
BY > 1984) %>%
group_by(stock) %>%
mutate(survZ = as.numeric(scale(surv))) %>%
ungroup(stock) %>%
arrange(region) %>%
mutate(stock = factor(stock, unique(stock))) %>%
select(-stockName, -jurisdiction, -lat, -long)
#focus on subset of BC pops for initial analyses
byDatTrim <- byDat %>%
dplyr::filter(region %in% c("LFR", "MFR", "UFR", "ECVI", "SPGSD", "NPGSD"),
BY > 1984) %>%
dplyr::group_by(stock) %>%
mutate(survZ = as.numeric(scale(surv))) %>%
ungroup(stock) %>%
arrange(region) %>%
mutate(stock = factor(stock, unique(stock))) %>%
select(-stockName, -jurisdiction, -lat, -long)
require("tidyverse")
listOfPackages <- c("here", "MARSS", "tidyverse", "ggplot2", "parallel",
"doParallel", "foreach", "tictoc")
lapply(listOfPackages, require, character.only = TRUE)
#helper functions to fit and post-process DFA
source(here("R/functions/dfaFunctions.R"))
byDat <- read.csv(here("data/salmonData/CLEANcwtInd_age2SR_BY.csv"),
stringsAsFactors = FALSE)
#focus on subset of BC pops for initial analyses
byDatTrim <- byDat %>%
dplyr::filter(region %in% c("LFR", "MFR", "UFR", "ECVI", "SPGSD", "NPGSD"),
BY > 1984) %>%
dplyr::group_by(stock) %>%
mutate(survZ = as.numeric(scale(surv))) %>%
ungroup(stock) %>%
arrange(region) %>%
mutate(stock = factor(stock, unique(stock))) %>%
select(-stockName, -jurisdiction, -lat, -long)
require("tidyverse")
instal
install.packages("lazyeval")
require("tidyverse")
#focus on subset of BC pops for initial analyses
byDatTrim <- byDat %>%
dplyr::filter(region %in% c("LFR", "MFR", "UFR", "ECVI", "SPGSD", "NPGSD"),
BY > 1984) %>%
dplyr::group_by(stock) %>%
mutate(survZ = as.numeric(scale(surv))) %>%
ungroup(stock) %>%
arrange(region) %>%
mutate(stock = factor(stock, unique(stock))) %>%
select(-stockName, -jurisdiction, -lat, -long)
head(byDatTrim)
range(byDatTrim$BY)
tail(byDatTrim)
byDatTrim %>% filter(BY == "2014")
subDir <- "salishSeaOnly"
summ <- getTopDFA(subDir)
subDir <- "salishSeaOnly_BY"
summ <- getTopDFA(subDir)
summ[[2]]
## Explore fit of top model
mod1 <- summ[[1]]
estZ <- coef(mod1, type = "matrix")$Z
#retrieve rotated matrix
invH <- if (ncol(estZ) > 1) {
varimax(estZ)$rotmat
} else if (ncol(estZ) == 1) {
1
}
coef(mdo1)
coef(mod1)
## Explore fit of top model
mod1 <- summ[[1]]
estZ <- coef(mod1, type = "matrix")$Z
#retrieve rotated matrix
invH <- if (ncol(estZ) > 1) {
varimax(estZ)$rotmat
} else if (ncol(estZ) == 1) {
1
}
summ
listOfPackages <- c("here", "MARSS", "tidyverse", "ggplot2", "parallel",
"doParallel", "foreach", "tictoc")
lapply(listOfPackages, require, character.only = TRUE)
byDat <- read.csv(here("data/salmonData/CLEANcwtInd_age2SR_BY.csv"),
stringsAsFactors = FALSE)
eyDat <- read.csv(here("data/salmonData/CLEANcwtInd_age2SR_OEY.csv"),
stringsAsFactors = FALSE)
#focus on subset of BC pops for initial analyses
byDatTrim <- byDat %>%
filter(region %in% c("LFR", "MFR", "UFR", "ECVI", "SPGSD", "NPGSD"))%>%
group_by(stock) %>%
mutate(survZ = as.numeric(scale(surv))) %>%
ungroup(stock) %>%
arrange(region) %>%
mutate(stock = factor(stock, unique(stock))) %>%
select(-stockName, -jurisdiction, -lat, -long)
byMatZ <- byDatTrim %>%
select(BY, stock, survZ) %>%
spread(key = stock, value = survZ) %>%
select(-BY) %>%
as.matrix() %>%
t()
broodYrs <- unique(byDatTrim$BY)
colnames(byMatZ) <- broodYrs
nStks <- nrow(byMatZ)
nYrs <- ncol(byMatZ)
stkID <- rownames(byMatZ)
## Fit models in parallel using multiple cores
inRSeq <- c("diagonal and equal", "diagonal and unequal", "equalvarcov")
inMList <- list(1, 2, 3, 4, 5, 6, 7)
subDir <- "salishSeaOnly_BY"
for (i in seq_along(inRSeq)) {
Ncores <- detectCores()
inRDum <- inRSeq[i]
cl <- makeCluster(Ncores - 2) #save two cores
registerDoParallel(cl)
clusterEvalQ(cl, c(library(MARSS), library(here), library(Rcpp),
library(RcppArmadillo)))
clusterExport(cl, c("byMatZ", "inRDum", "inMList", "fitDFA", "subDir"),
envir=environment())
tic("run in parallel")
parLapply(cl, inMList, function(x) {
fitDFA(byMatZ, inR = inRDum, inM = x, maxIteration = 1000,
subDirname = subDir)
})
stopCluster(cl) #end cluster
toc()
}
install.packages("mvtnorm")
inRSeq <- c("diagonal and equal", "diagonal and unequal", "equalvarcov")
inMList <- list(1, 2, 3, 4, 5, 6, 7)
subDir <- "salishSeaOnly_BY"
for (i in seq_along(inRSeq)) {
Ncores <- detectCores()
inRDum <- inRSeq[i]
cl <- makeCluster(Ncores - 2) #save two cores
registerDoParallel(cl)
clusterEvalQ(cl, c(library(MARSS), library(here), library(Rcpp),
library(RcppArmadillo)))
clusterExport(cl, c("byMatZ", "inRDum", "inMList", "fitDFA", "subDir"),
envir=environment())
tic("run in parallel")
parLapply(cl, inMList, function(x) {
fitDFA(byMatZ, inR = inRDum, inM = x, maxIteration = 1000,
subDirname = subDir)
})
stopCluster(cl) #end cluster
toc()
}
install.packages("KFAS")
install.packages("MARSS")
inRSeq <- c("diagonal and equal", "diagonal and unequal", "equalvarcov")
inMList <- list(1, 2, 3, 4, 5, 6, 7)
subDir <- "salishSeaOnly_BY"
for (i in seq_along(inRSeq)) {
Ncores <- detectCores()
inRDum <- inRSeq[i]
cl <- makeCluster(Ncores - 2) #save two cores
registerDoParallel(cl)
clusterEvalQ(cl, c(library(MARSS), library(here), library(Rcpp),
library(RcppArmadillo)))
clusterExport(cl, c("byMatZ", "inRDum", "inMList", "fitDFA", "subDir"),
envir=environment())
tic("run in parallel")
parLapply(cl, inMList, function(x) {
fitDFA(byMatZ, inR = inRDum, inM = x, maxIteration = 1000,
subDirname = subDir)
})
stopCluster(cl) #end cluster
toc()
}
install.packages("RcppArmadillo")
inRSeq <- c("diagonal and equal", "diagonal and unequal", "equalvarcov")
inMList <- list(1, 2, 3, 4, 5, 6, 7)
subDir <- "salishSeaOnly_BY"
for (i in seq_along(inRSeq)) {
Ncores <- detectCores()
inRDum <- inRSeq[i]
cl <- makeCluster(Ncores - 2) #save two cores
registerDoParallel(cl)
clusterEvalQ(cl, c(library(MARSS), library(here), library(Rcpp),
library(RcppArmadillo)))
clusterExport(cl, c("byMatZ", "inRDum", "inMList", "fitDFA", "subDir"),
envir=environment())
tic("run in parallel")
parLapply(cl, inMList, function(x) {
fitDFA(byMatZ, inR = inRDum, inM = x, maxIteration = 1000,
subDirname = subDir)
})
stopCluster(cl) #end cluster
toc()
}
subDir
fitDFA
for (i in seq_along(inRSeq)) {
Ncores <- detectCores()
inRDum <- inRSeq[i]
cl <- makeCluster(Ncores - 2) #save two cores
registerDoParallel(cl)
clusterEvalQ(cl, c(library(MARSS), library(here), library(Rcpp),
library(RcppArmadillo)))
clusterExport(cl, c("byMatZ", "inRDum", "inMList", "fitDFA", "subDir"),
envir=environment())
tic("run in parallel")
parLapply(cl, inMList, function(x) {
fitDFA(byMatZ, inR = inRDum, inM = x, maxIteration = 1000,
subDirName = subDir)
})
stopCluster(cl) #end cluster
toc()
}
summ <- getTopDFA(subDir)
summ[[2]]
## Explore fit of top model
mod1 <- summ[[1]]
estZ <- coef(mod1, type = "matrix")$Z
#retrieve rotated matrix
invH <- if (ncol(estZ) > 1) {
varimax(estZ)$rotmat
} else if (ncol(estZ) == 1) {
1
}
summ[[1]]
coef(mod1, type= "matrix")
coef(mod1)
summary(mod1)
subDir
tt <- getTopDFA("salishSeaOnly_short_BY")
tt[[1]]
mod1 <- tt[[1]]
estZ <- coef(mod1, type = "matrix")$Z
#retrieve rotated matrix
invH <- if (ncol(estZ) > 1) {
varimax(estZ)$rotmat
} else if (ncol(estZ) == 1) {
1
}
coef(mod1, type = "matrix")$Z
subDirName <- subDir
subDirName
dirPath <- here::here("data", "dfaFits", subDirName)
modOutNames <- list.files(dirPath, pattern="\\.rds$")
modOut <- data.frame(model = rep(NA, times = length(modOutNames)),
AICc = NA
)
for(i in 1:length(modOutNames)){ #make list of lists!
dum <- readRDS(paste(dirPath, modOutNames[i], sep="/"))
modOut[i, "model"] <- modOutNames[i]
modOut[i, "AICc"] <- ifelse(is.null(dum$AICc), NA, dum$AICc)
}
aicTable <- modOut %>%
arrange(AICc)
aicTable
topModelName <- aicTable %>%
filter(AICc == min(AICc, na.rm = TRUE)) %>%
select(model) %>%
as.character()
topModel <- readRDS(paste(dirPath, topModelName, sep = "/"))
str(topModel)
nStks
par(mod1)
warnings()
mod1$par$Z
coef(mod1, type = "matrix")$Z
coef(mod1)
str(mod1)
mod1[["par"]][["Z"]]
mod1[["call"]][["m"]]
mod1[["call"]]
mod1[["call"]]$m
mod1$call$m
mod1$call$model$m
matrix(mod1[["par"]][["Z"]], ncol = mod1$call$model$m)
## Strong support for using diagonal and unequal covariance matrix and
# intermediate number of trends
ddd <- getTopDFA("salishSeaOnly_short_BY")
str(ddd)
subDir <- "salishSeaOnly_short_BY" #for data cropped at 1985
inRSeq <- c("diagonal and unequal", "equalvarcov")
dfaSummary <- getTopDFA(subDir)
dfaSummary[[2]] #prints AIC table
mod1 <- dfaSummary[[1]]
estZ <- coef(mod1, type = "matrix")$Z
#retrieve rotated matrix
invH <- if (ncol(estZ) > 1) {
varimax(estZ)$rotmat
} else if (ncol(estZ) == 1) {
1
}
estZ
dfaTest <- MARSS(byMatZ, model = modelList, z.score = TRUE, form = "dfa",
control = cntrList, method = "BFGS-kf")
listOfPackages <- c("here", "MARSS", "tidyverse", "ggplot2", "parallel",
"doParallel", "foreach", "tictoc")
lapply(listOfPackages, require, character.only = TRUE)
dfaTest <- MARSS(byMatZ, model = modelList, z.score = TRUE, form = "dfa",
control = cntrList, method = "BFGS-kf")
modelList <- list(m = 2, R = "diagonal and equal")
cntrList <- list(maxit = 200)
dfaTest <- MARSS(byMatZ, model = modelList, z.score = TRUE, form = "dfa",
control = cntrList, method = "BFGS-kf")
dfaTest <- MARSS(byMatZ, model = modelList, z.score = TRUE, form = "dfa",
control = cntrList, method = "kem")
coef(dfaTest)
coef(dfaTest, type = "matrix")
coef(dfaTest, type = "matrix")$Z
str(dfaTest)
coef(dfaTest)
coef(mod1)
summ <- getTopDFA(subDir)
summ[[2]]
## Explore fit of top model
mod1 <- summ[[1]]
coef(mod1)
coef(mod1, type = "matrix")$Z
?coef
listOfPackages <- c("here", "MARSS", "tidyverse", "ggplot2", "parallel",
"doParallel", "foreach", "tictoc")
lapply(listOfPackages, require, character.only = TRUE)
byDat <- read.csv(here("data/salmonData/CLEANcwtInd_age2SR_BY.csv"),
stringsAsFactors = FALSE)
eyDat <- read.csv(here("data/salmonData/CLEANcwtInd_age2SR_OEY.csv"),
stringsAsFactors = FALSE)
#focus on subset of BC pops for initial analyses
byDatTrim <- byDat %>%
filter(region %in% c("LFR", "MFR", "UFR", "ECVI", "SPGSD", "NPGSD"))%>%
group_by(stock) %>%
mutate(survZ = as.numeric(scale(surv))) %>%
ungroup(stock) %>%
arrange(region) %>%
mutate(stock = factor(stock, unique(stock))) %>%
select(-stockName, -jurisdiction, -lat, -long)
## Explore fit of top model
mod1 <- summ[[1]]
estZ <- MARSS::coef(mod1, type = "matrix")$Z
estZ <- coef(mod1, type = "matrix")$Z
#retrieve rotated matrix
invH <- if (ncol(estZ) > 1) {
varimax(estZ)$rotmat
} else if (ncol(estZ) == 1) {
1
}
## Factor loadings
#rotate factor loadings
rotZ <- (estZ %*% invH) %>%
as.data.frame() %>%
mutate(stock = stkID) %>%
inner_join(byDatTrim %>% select(stock, region), by = "stock") %>%
gather(key = "trend", value = "loading", -stock, -region) %>%
distinct() %>%
arrange(region) %>%
mutate(trend = fct_recode(as.factor(trend),
trend1 = "V1",
trend2 = "V2",
trend3 = "V3",
trend4 = "V4"),
stock = factor(stock, unique(stock)))
subDir
subDir <- "salishSeaOnly_BY"
summ <- getTopDFA(subDir)
summ[[2]]
## Explore fit of top model
mod1 <- summ[[1]]
estZ <- coef(mod1, type = "matrix")$Z
#retrieve rotated matrix
invH <- if (ncol(estZ) > 1) {
varimax(estZ)$rotmat
} else if (ncol(estZ) == 1) {
1
}
## Factor loadings
#rotate factor loadings
rotZ <- (estZ %*% invH) %>%
as.data.frame() %>%
mutate(stock = stkID) %>%
inner_join(byDatTrim %>% select(stock, region), by = "stock") %>%
gather(key = "trend", value = "loading", -stock, -region) %>%
distinct() %>%
arrange(region) %>%
mutate(trend = fct_recode(as.factor(trend),
trend1 = "V1",
trend2 = "V2",
trend3 = "V3",
trend4 = "V4"),
stock = factor(stock, unique(stock)))
ggplot(rotZ, aes(x = stock, y = loading, fill = region)) +
geom_col() +
theme_sleekX(axisSize = 9, legendSize = 0.7) +
theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
facet_wrap(~trend)
ggplot(rotZ, aes(x = stock, y = loading, fill = region)) +
geom_col() +
samSim::theme_sleekX(axisSize = 9, legendSize = 0.7) +
theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
facet_wrap(~trend)
## Trends
#rotate trends
rotTrends <- (solve(invH) %*% mod1$states) %>%
t() %>%
as.data.frame() %>%
mutate(year = broodYrs) %>%
gather(key = "trend", value = "est", -year) %>%
mutate(trend = fct_recode(as.factor(trend),
trend1 = "V1",
trend2 = "V2",
trend3 = "V3",
trend4 = "V4"))
ggplot(rotTrends, aes(x = year, y = est)) +
geom_line() +
theme_sleekX() +
geom_hline(yintercept = 0, colour = "red") +
facet_wrap(~trend)
ggplot(rotTrends, aes(x = year, y = est)) +
geom_line() +
samSim::theme_sleekX() +
geom_hline(yintercept = 0, colour = "red") +
facet_wrap(~trend)
## Plot fitted estimates
modOutCI <- broom::augment(mod1, interval = "confidence") %>%
dplyr::rename(stock = .rownames) %>%
inner_join(byDatTrim %>% select(stock, region), by = "stock") %>%
distinct() %>%
mutate(year = t + 1970,
stock = as.factor(stock)) %>%
arrange(region)
ggplot(modOutCI) +
geom_line(aes(x = year, y = .fitted)) +
geom_point(aes(x = year, y = y, colour = region)) +
geom_ribbon(aes(x = year, ymin = .conf.low, ymax = .conf.up), linetype = 2,
alpha = 0.2) +
facet_wrap(~stock)
listOfPackages <- c("here", "bayesDFA", "tidyverse", "ggplot2", "parallel",
"doParallel", "foreach", "tictoc")
lapply(listOfPackages, require, character.only = TRUE)
install.packages("bayesDFA")
devtools::install_github("fate-ewi/bayesdfa")
install.packages("bayesDFA")
install.packages("bayesDFA")
if(!require(installr)) { install.packages("installr"); require(installr)}
updateR(F, T, T, F, T, F, T)
