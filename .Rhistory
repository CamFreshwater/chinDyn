stk_tbl <- gen %>%
select(stock, stock_name, run, a_group:a_group3) %>%
distinct()
stk_tbl
gen_raw <- readRDS(here::here("data", "salmonData", "cwt_indicator_surv_clean.RDS"))
#remove stocks with no gen_length data
gen <- gen_raw %>%
filter(!is.na(gen_length))
# dataframe of only stocks and adult groupings
stk_tbl <- gen %>%
select(stock, stock_name, region, run, a_group:a_group3) %>%
distinct()
stk_tbl
# specify the z models based on different groups
z1 <- factor(stk_tbl$run)
z2 <-  factor(stk_tbl$a_group)
z3 <- factor(stk_tbl$a_group2)
z4 <- factor(stk_tbl$a_group3)
z_models <- list(z1, z2, z3, z4)
names(z_models) <- c("run", "off-shelf", "region", "region2")
length(z_1)
length(z1)
ncol(gen_mat)
head(gen_mat)
gen_raw <- readRDS(here::here("data", "salmonData", "cwt_indicator_surv_clean.RDS"))
#remove stocks with no gen_length data
gen <- gen_raw %>%
filter(!is.na(gen_length))
# dataframe of only stocks and adult groupings
stk_tbl <- gen %>%
select(stock, stock_name, run, a_group:a_group3) %>%
distinct()
nrow(stk_tbl)
length(unique(stock$gen))
length(unique(gen_raw$stock))
# make matrix of natural mortality rates
gen_mat <- gen %>%
select(year, stock, gen_length) %>%
pivot_wider(names_from = stock, values_from = gen_length) %>%
arrange(year) %>%
as.matrix() %>%
t()
gen_mat <- gen_mat[2:nrow(gen_mat), ]
head(gen_mat)
nrow(gen_mat)
gen_mat <- gen_mat[2:nrow(gen_mat), ]
colnames(gen_mat) <- seq(min(gen$year), max(gen$year), by = 1)
n_ts <- nrow(gen_mat)
tt <- ncol(gen_mat)
# specify the z models based on different groups
z1 <- factor(stk_tbl$run)
z2 <-  factor(stk_tbl$a_group)
z3 <- factor(stk_tbl$a_group2)
z4 <- factor(stk_tbl$a_group3)
z_models <- list(z1, z2, z3, z4)
names(z_models) <- c("run", "off-shelf", "region", "region2")
q_models <- c("diagonal and equal",
"diagonal and unequal",
"equalvarcov",
"unconstrained")
U <- "unequal"
R <- "diagonal and equal"
A <- "scaling"
B <- "identity"
x0 <- "unequal"
V0 <- "zero"
model_constants <- list(U = U, R = R, A = A, B = B, x0 = x0, V0 = V0)
n
# function to fit models
fit_marss <- function(z_name, z_in, q_in) {
fit_model <- c(list(Z = z_in, Q = q_in), model_constants)
fit <- MARSS(m_mat, model = fit_model,
silent = FALSE, control = list(minit = 100, maxit = 500))
if (fit$convergence != 0){
fit <- MARSS(m_mat,
model = fit_model,
control = list(maxit=4000, trace=1),
inits = as.matrix(coef(fit)[1]),
method = "BFGS")
}
out <- data.frame(
H = z_name, Q = q_in, U = U,
logLik = fit$logLik, AICc = fit$AICc, num.param = fit$num.params,
m = length(unique(z_in)),
num.iter = fit$numIter,
converged = !fit$convergence,
stringsAsFactors = FALSE)
list(fit = fit, out = out)
}
# tibble containing model combinations
mod_names = expand.grid(q = q_models, z = names(z_models)) %>%
mutate(name = paste(z, q, sep = "-"))
mod_tbl <- tibble(
mod_name = mod_names$name,
z_name = mod_names$z,
q_name = mod_names$q,
z_models = rep(z_models, each = 4),
q_models = rep(q_models, times = 4)
)
mod_tbl
fit_marss(z_name = mod_tbl$z_name[[1]],
z_in = mod_tbl$z_models[[1]],
q_in = mod_tbl$q_models[[1]])
# function to fit models
fit_marss <- function(z_name, z_in, q_in) {
fit_model <- c(list(Z = z_in, Q = q_in), model_constants)
fit <- MARSS(gen_mat, model = fit_model,
silent = FALSE, control = list(minit = 100, maxit = 500))
if (fit$convergence != 0){
fit <- MARSS(gen_mat,
model = fit_model,
control = list(maxit=4000, trace=1),
inits = as.matrix(coef(fit)[1]),
method = "BFGS")
}
out <- data.frame(
H = z_name, Q = q_in, U = U,
logLik = fit$logLik, AICc = fit$AICc, num.param = fit$num.params,
m = length(unique(z_in)),
num.iter = fit$numIter,
converged = !fit$convergence,
stringsAsFactors = FALSE)
list(fit = fit, out = out)
}
fit_marss(z_name = mod_tbl$z_name[[1]],
z_in = mod_tbl$z_models[[1]],
q_in = mod_tbl$q_models[[1]])
dim(gen_mat)
row.names(gen_mat)
stk_tbl %>% filter(!stock %in% row.names(gen_mat))
gen %>% filter(stock == "ATN")
head(gen_mat)
glimpse(gen)
gen %>%
select(year, stock, gen_length) %>%
pivot_wider(names_from = stock, values_from = gen_length)
gen %>%
select(year, stock, gen_length) %>%
pivot_wider(names_from = stock, values_from = gen_length) %>%
arrange(year) %>%
as.matrix() %>%
t()
gen_mat <- gen_mat[2:nrow(gen_mat), ]
head(gen_mat)
nrow(gen_mat)
# make matrix of natural mortality rates
gen_mat <- gen %>%
select(year, stock, gen_length) %>%
pivot_wider(names_from = stock, values_from = gen_length) %>%
arrange(year) %>%
as.matrix() %>%
t()
head(gen_mat)
gen_mat[2:nrow(gen_mat), ]
# make matrix of natural mortality rates
gen_mat1 <- gen %>%
select(year, stock, gen_length) %>%
pivot_wider(names_from = stock, values_from = gen_length) %>%
arrange(year) %>%
as.matrix() %>%
t()
gen_mat <- gen_mat1[2:nrow(gen_mat1), ]
head(gen_mat)
nrow(gen_mat)
colnames(gen_mat) <- seq(min(gen$year), max(gen$year), by = 1)
n_ts <- nrow(gen_mat)
tt <- ncol(gen_mat)
n_ts
# specify the z models based on different groups
z1 <- factor(stk_tbl$run)
z2 <-  factor(stk_tbl$a_group)
z3 <- factor(stk_tbl$a_group2)
z4 <- factor(stk_tbl$a_group3)
z_models <- list(z1, z2, z3, z4)
names(z_models) <- c("run", "off-shelf", "region", "region2")
q_models <- c("diagonal and equal",
"diagonal and unequal",
"equalvarcov",
"unconstrained")
U <- "unequal"
R <- "diagonal and equal"
A <- "scaling"
B <- "identity"
x0 <- "unequal"
V0 <- "zero"
model_constants <- list(U = U, R = R, A = A, B = B, x0 = x0, V0 = V0)
# function to fit models
fit_marss <- function(z_name, z_in, q_in) {
fit_model <- c(list(Z = z_in, Q = q_in), model_constants)
fit <- MARSS(gen_mat, model = fit_model,
silent = FALSE, control = list(minit = 100, maxit = 500))
if (fit$convergence != 0){
fit <- MARSS(gen_mat,
model = fit_model,
control = list(maxit=4000, trace=1),
inits = as.matrix(coef(fit)[1]),
method = "BFGS")
}
out <- data.frame(
H = z_name, Q = q_in, U = U,
logLik = fit$logLik, AICc = fit$AICc, num.param = fit$num.params,
m = length(unique(z_in)),
num.iter = fit$numIter,
converged = !fit$convergence,
stringsAsFactors = FALSE)
list(fit = fit, out = out)
}
# tibble containing model combinations
mod_names = expand.grid(q = q_models, z = names(z_models)) %>%
mutate(name = paste(z, q, sep = "-"))
mod_tbl <- tibble(
mod_name = mod_names$name,
z_name = mod_names$z,
q_name = mod_names$q,
z_models = rep(z_models, each = 4),
q_models = rep(q_models, times = 4)
)
fit_marss(z_name = mod_tbl$z_name[[1]],
z_in = mod_tbl$z_models[[1]],
q_in = mod_tbl$q_models[[1]])
# fit generic MARSS models
marss_list <- furrr::future_pmap(list(z_name = mod_tbl$z_name,
z_in = mod_tbl$z_models,
q_in = mod_tbl$q_models),
.f = fit_marss,
.progress = TRUE)
marss_list
# fit generic MARSS models
marss_list <- furrr::future_pmap(list(z_name = mod_tbl$z_name,
z_in = mod_tbl$z_models,
q_in = mod_tbl$q_models),
.f = fit_marss,
.progress = TRUE)
z_models
MARSS(gen_mat, model =  c(list(Z = z_models[[1]],
Q = "diagonal and unequal"),
model_constants),
silent = FALSE, control = list(maxit = 100),
method = "BFGS")
MARSS(gen_mat, model =  c(list(Z = z_models[[1]],
Q = "equalvarcov"),
model_constants),
silent = FALSE, control = list(maxit = 100),
method = "BFGS")
MARSS(gen_mat, model =  c(list(Z = z_models[[1]],
Q = "unconstrained"),
model_constants),
silent = FALSE, control = list(maxit = 100),
method = "BFGS")
# function to fit models
fit_marss <- function(z_name, z_in, q_in) {
fit_model <- c(list(Z = z_in, Q = q_in), model_constants)
fit <- MARSS(gen_mat, model = fit_model,
silent = FALSE, control = list(minit = 100, maxit = 500))
#use BFGS except when equalvarcov (can't fit)
if (fit$convergence != 0 & q_in != "equalvarcov"){
fit <- MARSS(gen_mat,
model = fit_model,
control = list(maxit=4000, trace=1),
inits = as.matrix(coef(fit)[1]),
method = "BFGS")
}
out <- data.frame(
H = z_name, Q = q_in, U = U,
logLik = fit$logLik, AICc = fit$AICc, num.param = fit$num.params,
m = length(unique(z_in)),
num.iter = fit$numIter,
converged = !fit$convergence,
stringsAsFactors = FALSE)
list(fit = fit, out = out)
}
# tibble containing model combinations
mod_names = expand.grid(q = q_models, z = names(z_models)) %>%
mutate(name = paste(z, q, sep = "-"))
mod_tbl <- tibble(
mod_name = mod_names$name,
z_name = mod_names$z,
q_name = mod_names$q,
z_models = rep(z_models, each = 4),
q_models = rep(q_models, times = 4)
)
# fit generic MARSS models
marss_list <- furrr::future_pmap(list(z_name = mod_tbl$z_name,
z_in = mod_tbl$z_models,
q_in = mod_tbl$q_models),
.f = fit_marss,
.progress = TRUE)
marss_aic_tab <- purrr::map(marss_list, "out") %>%
bind_rows() %>%
arrange(AICc) %>%
mutate(deltaAICc = AICc - min(AICc),
rel_like = exp(-1 * deltaAICc / 2),
aic_weight = rel_like / sum(rel_like))
marss_aic_tab
unique(stk_tbl$region)
unique(stk_tbl$a_group2)
#plot raw generation length data
gen  %>%
ggplot(.) +
geom_point(aes(x = year, y = gen_length, fill = a_group), shape = 21) +
facet_wrap(~ fct_reorder(stock, as.numeric(a_group))) +
theme(legend.position = "top") +
labs(y = "Mean Generation Length") +
ggsidekick::theme_sleek()
#plot raw generation length data
gen  %>%
ggplot(.) +
geom_point(aes(x = year, y = gen_length, fill = a_group2), shape = 21) +
facet_wrap(~ fct_reorder(stock, as.numeric(a_group2))) +
theme(legend.position = "top") +
labs(y = "Mean Generation Length") +
ggsidekick::theme_sleek()
saveRDS(marss_list, here::here("data", "generation_fits",
"marss_selection_fits.RDS"))
saveRDS(marss_aic_tab, here::here("data", "generation_fits",
"marss_aic_tab.RDS"))
glimpse(gen)
#remove stocks with no gen_length data
gen <- gen_raw %>%
filter(!is.na(gen_length)) %>%
mutate(gen_z = as.numeric(scale(gen_length)))
# make matrix of natural mortality rates
gen_mat1 <- gen %>%
select(year, stock, gen_length) %>%
pivot_wider(names_from = stock, values_from = gen_length) %>%
arrange(year) %>%
as.matrix() %>%
t()
# make matrix of natural mortality rates
gen_mat1 <- gen %>%
select(year, stock, gen_length) %>%
pivot_wider(names_from = stock, values_from = gen_z) %>%
arrange(year) %>%
as.matrix() %>%
t()
#remove stocks with no gen_length data
gen <- gen_raw %>%
filter(!is.na(gen_length)) %>%
mutate(gen_z = as.numeric(scale(gen_length)))
#remove stocks with no gen_length data
gen <- gen_raw %>%
filter(!is.na(gen_length)) %>%
mutate(gen_z = as.numeric(scale(gen_length)))
# make matrix of natural mortality rates
gen_mat1 <- gen %>%
select(year, stock, gen_length) %>%
pivot_wider(names_from = stock, values_from = gen_z) %>%
arrange(year) %>%
as.matrix() %>%
t()
#remove stocks with no gen_length data
gen <- gen_raw %>%
filter(!is.na(gen_length)) %>%
mutate(gen_z = as.numeric(scale(gen_length)))
glimpse(gen)
# make matrix of natural mortality rates
gen_mat1 <- gen %>%
select(year, stock, gen_length) %>%
pivot_wider(names_from = stock, values_from = gen_z) %>%
arrange(year) %>%
as.matrix() %>%
t()
# make matrix of natural mortality rates
gen_mat1 <- gen %>%
select(year, stock, gen_z) %>%
pivot_wider(names_from = stock, values_from = gen_z) %>%
arrange(year) %>%
as.matrix() %>%
t()
gen_mat <- gen_mat1[2:nrow(gen_mat1), ]
colnames(gen_mat) <- seq(min(gen$year), max(gen$year), by = 1)
n_ts <- nrow(gen_mat)
tt <- ncol(gen_mat)
## Generic MARSS approach
# specify the z models based on different groups
z1 <- factor(stk_tbl$run)
z2 <-  factor(stk_tbl$a_group)
z3 <- factor(stk_tbl$a_group2)
z4 <- factor(stk_tbl$a_group3)
z_models <- list(z1, z2, z3, z4)
names(z_models) <- c("run", "off-shelf", "region", "region2")
q_models <- c("diagonal and equal",
"diagonal and unequal",
"equalvarcov",
"unconstrained")
U <- "unequal"
R <- "diagonal and equal"
A <- "scaling"
B <- "identity"
x0 <- "unequal"
V0 <- "zero"
model_constants <- list(U = U, R = R, A = A, B = B, x0 = x0, V0 = V0)
head(gen_mat)
# tibble containing model combinations
mod_names = expand.grid(q = q_models, z = names(z_models)) %>%
mutate(name = paste(z, q, sep = "-"))
mod_tbl <- tibble(
mod_name = mod_names$name,
z_name = mod_names$z,
q_name = mod_names$q,
z_models = rep(z_models, each = 4),
q_models = rep(q_models, times = 4)
)
# fit generic MARSS models
marss_list <- furrr::future_pmap(list(z_name = mod_tbl$z_name,
z_in = mod_tbl$z_models,
q_in = mod_tbl$q_models),
.f = fit_marss,
.progress = TRUE)
marss_aic_tab <- purrr::map(marss_list, "out") %>%
bind_rows() %>%
arrange(AICc) %>%
mutate(deltaAICc = AICc - min(AICc),
rel_like = exp(-1 * deltaAICc / 2),
aic_weight = rel_like / sum(rel_like))
marss_aic_tab
library(bayesdfa)
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
a_palette <- disco::disco("muted", n = length(unique(surv$a_group3)))
names(a_palette) <- unique(surv$a_group3)
library(rstan)
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
a_palette <- disco::disco("muted", n = length(unique(surv$a_group3)))
names(a_palette) <- unique(gen$a_group3)
a_palette <- disco::disco("muted", n = length(unique(gen$a_group3)))
names(a_palette) <- unique(gen$a_group3)
a_palette
a_palette <- disco::disco("muted", n = length(unique(gen$a_group2)))
names(a_palette) <- unique(gen$a_group2)
#helper function to spread and label input matrices for bayesdfa
make_mat <- function(x) {
mat1 <- x %>%
select(year, stock, M) %>%
spread(key = stock, value = M) %>%
as.matrix()
out_mat <- t(mat1[, 2:ncol(mat1)])
colnames(out_mat) <- mat1[, "year"]
return(out_mat)
}
stk_tbl %>%
group_by(a_group) %>%
tally()
stk_tbl %>%
group_by(a_group2) %>%
tally()
# number of stocks per group
kept_grps <- stk_tbl %>%
group_by(a_group2) %>%
tally() %>%
filter(n > 2)
tibble(group = levels(surv$a_group2)) %>%
mutate(
m_mat = surv %>%
filter(!is.na(M)) %>%
group_split(a_group2) %>%
map(., make_mat)
) %>%
# remove groups with less than three time series
filter(
group %in% kept_grps$a_group2
)
tibble(group = levels(gen$a_group2)) %>%
mutate(
m_mat = gen %>%
filter(!is.na(M)) %>%
group_split(a_group2) %>%
map(., make_mat)
) %>%
# remove groups with less than three time series
filter(
group %in% kept_grps$a_group2
)
#generate tbl by group
surv_tbl <- tibble(group = levels(gen$a_group2)) %>%
mutate(
m_mat = gen %>%
filter(!is.na(M)) %>%
group_split(a_group2) %>%
map(., make_mat)
) %>%
# remove groups with less than three time series
filter(
group %in% kept_grps$a_group2
)
#generate tbl by group
gen_tbl <- tibble(group = levels(gen$a_group2)) %>%
mutate(
m_mat = gen %>%
filter(!is.na(M)) %>%
group_split(a_group2) %>%
map(., make_mat)
) %>%
# remove groups with less than three time series
filter(
group %in% kept_grps$a_group2
)
gen_tbl$names <- map(gen_tbl$m_mat, function (x) {
data.frame(stock = row.names(x)) %>%
left_join(., gen %>% select(stock, stock_name) %>% distinct(),
by = "stock")
})
gen_tbl
dfa_fits <- furrr::future_map(gen_tbl$m_mat, .f = fit_dfa,
num_trends = 2, zscore = TRUE,
iter = 1500, chains = 4, thin = 1,
control = list(adapt_delta = 0.95,
max_treedepth = 20),
.progress = TRUE,
seed = TRUE)
saveRDS(dfa_fits, here::here("data", "generation_fits", "bayesdfa_by_group.RDS"))
