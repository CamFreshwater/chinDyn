a_name = mod_names$a,
z_models = rep(z_models, each = length(unique(q_models))),
q_models = rep(q_models, length.out = length(mod_names$name)),
a_models = rep(a_models, length.out = length(mod_names$name))
)
library(MARSS)
library(tidyverse)
# prep multisession
ncores <- parallel::detectCores()
future::plan(future::multisession, workers = ncores - 2)
gen_raw <- readRDS(here::here("data", "salmonData",
"cwt_indicator_surv_clean.RDS"))
gen <- gen_raw %>%
filter(!is.na(gen_length),
#!j_group3 %in% c("col_streamtype", "north_oceantype",
# "sog_streamtype"),
#!a_group3 == "north_streamtype"
) %>%
group_by(stock) %>%
mutate(gen_z = as.numeric(scale(gen_length)),
gen_cent = as.numeric(scale(gen_length, center = TRUE,
scale = FALSE))) %>%
ungroup() %>%
droplevels()
map(colnames(gen)[which(colnames(gen) %in% c("smolt", "run") |
str_detect(colnames(gen), "group"))],
function(x) {
gen %>%
select(stock_name, .data[[x]]) %>%
distinct() %>%
group_by(.data[[x]]) %>%
tally()
})
# dataframe of only stocks and adult groupings
stk_tbl <- gen %>%
group_by(stock) %>%
mutate(max_age = ceiling(max(gen_length)),
max_ocean_age = ifelse(smolt == "oceantype", max_age - 1,
max_age - 2)) %>%
ungroup() %>%
select(stock, stock_name, max_age, max_ocean_age, smolt, run,
j_group1:j_group4, a_group1:a_group4, j_group4b:j_group1b) %>%
distinct()
# make matrix
gen_mat1 <- gen %>%
select(year, stock, gen_cent) %>%
pivot_wider(names_from = stock, values_from = gen_cent) %>%
arrange(year) %>%
as.matrix() %>%
t()
gen_mat <- gen_mat1[2:nrow(gen_mat1), ]
colnames(gen_mat) <- seq(min(gen$year), max(gen$year), by = 1)
n_ts <- nrow(gen_mat)
tt <- ncol(gen_mat)
## Generic MARSS approach (model selection)
# specify the z models based on different groupings (smolt, run, a dist, j dist)
z_model_inputs <- colnames(gen)[which(colnames(gen) %in% c("smolt", "run") |
str_detect(colnames(gen), "group"))]
z_models <- map(z_model_inputs, function (x) {
stk_tbl %>%
pull(.data[[x]]) %>%
factor()
})
names(z_models) <- z_model_inputs
q_models <- c("diagonal and unequal", "unconstrained")
# a_models <- c("scaling", "zero")
U <- "unequal"
R <- "diagonal and unequal"
A <- "scaling"
B <- "identity"
x0 <- "unequal"
V0 <- "zero"
model_constants <- list(U = U, B = B, x0 = x0, A = A, V0 = V0)
# function to fit models
fit_marss <- function(z_name, z_in, q_in) {
fit_model <- c(list(Z = z_in, Q = q_in), model_constants)
fit <- MARSS(gen_mat, model = fit_model,
silent = FALSE, control = list(minit = 100, maxit = 500))
#use BFGS except when equalvarcov (can't fit)
if (fit$convergence != 0 & q_in != "equalvarcov"){
fit <- MARSS(gen_mat,
model = fit_model,
control = list(maxit=4000, trace=1),
inits = as.matrix(coef(fit)[1]),
method = "BFGS")
}
out <- data.frame(
H = z_name, Q = q_in, U = U,
logLik = fit$logLik, AICc = fit$AICc, num.param = fit$num.params,
m = length(unique(z_in)),
num.iter = fit$numIter,
converged = !fit$convergence,
stringsAsFactors = FALSE)
list(fit = fit, out = out)
}
mod_names = expand.grid(q = q_models,
z = names(z_models),) %>%
mutate(name = paste(z, q, sep = "-"))
mod_tbl <- tibble(
mod_name = mod_names$name,
z_name = mod_names$z,
q_name = mod_names$q,
z_models = rep(z_models, each = length(unique(q_models))),
q_models = rep(q_models, length.out = length(mod_names$name))
)
z_model_inputs <- colnames(gen)[which(colnames(gen) %in% c("smolt", "run") |
str_detect(colnames(gen), "group"))]
z_models <- map(z_model_inputs, function (x) {
stk_tbl %>%
pull(.data[[x]]) %>%
factor()
})
names(z_models) <- z_model_inputs
q_models <- c("diagonal and unequal", "unconstrained")
# a_models <- c("scaling", "zero")
U <- "unequal"
R <- "diagonal and unequal"
A <- "scaling"
B <- "identity"
x0 <- "unequal"
V0 <- "zero"
model_constants <- list(U = U, B = B, x0 = x0, A = A, V0 = V0)
# function to fit models
fit_marss <- function(z_name, z_in, q_in) {
fit_model <- c(list(Z = z_in, Q = q_in), model_constants)
fit <- MARSS(gen_mat, model = fit_model,
silent = FALSE, control = list(minit = 100, maxit = 500))
#use BFGS except when equalvarcov (can't fit)
if (fit$convergence != 0 & q_in != "equalvarcov"){
fit <- MARSS(gen_mat,
model = fit_model,
control = list(maxit=4000, trace=1),
inits = as.matrix(coef(fit)[1]),
method = "BFGS")
}
out <- data.frame(
H = z_name, Q = q_in, U = U,
logLik = fit$logLik, AICc = fit$AICc, num.param = fit$num.params,
m = length(unique(z_in)),
num.iter = fit$numIter,
converged = !fit$convergence,
stringsAsFactors = FALSE)
list(fit = fit, out = out)
}
# tibble containing model combinations
mod_names = expand.grid(q = q_models,
z = names(z_models),) %>%
mutate(name = paste(z, q, sep = "-"))
# tibble containing model combinations
mod_names = expand.grid(q = q_models,
z = names(z_models)) %>%
mutate(name = paste(z, q, sep = "-"))
mod_tbl <- tibble(
mod_name = mod_names$name,
z_name = mod_names$z,
q_name = mod_names$q,
z_models = rep(z_models, each = length(unique(q_models))),
q_models = rep(q_models, length.out = length(mod_names$name))
)
mod_tbl
# function to fit models
fit_marss <- function(z_name, z_in, q_in) {
fit_model <- c(list(Z = z_in, Q = q_in), model_constants)
fit <- MARSS(gen_mat, model = fit_model,
silent = FALSE, control = list(minit = 100, maxit = 500))
#use BFGS except when equalvarcov (can't fit)
if (fit$convergence != 0 & q_in != "equalvarcov"){
fit <- MARSS(gen_mat,
model = fit_model,
control = list(maxit=4000, trace=1),
inits = as.matrix(coef(fit)[1]),
method = "BFGS")
}
out <- data.frame(
H = z_name, Q = q_in, U = U,
logLik = fit$logLik, AICc = fit$AICc, num.param = fit$num.params,
m = length(unique(z_in)),
num.iter = fit$numIter,
converged = !fit$convergence,
stringsAsFactors = FALSE)
list(fit = fit, out = out)
}
# fit generic MARSS models
marss_list <- furrr::future_pmap(list(z_name = mod_tbl$z_name,
z_in = mod_tbl$z_models,
q_in = mod_tbl$q_models),
.f = fit_marss,
.progress = TRUE)
marss_aic_tab <- purrr::map(marss_list, "out") %>%
bind_rows() %>%
arrange(AICc) %>%
mutate(deltaAICc = AICc - min(AICc),
rel_like = exp(-1 * deltaAICc / 2),
aic_weight = rel_like / sum(rel_like))
marss_aic_tab
saveRDS(marss_aic_tab, here::here("data", "generation_fits",
"marss_aic_tab_scalingA_centered.RDS"))
A <- "zero"
# function to fit models
fit_marss <- function(z_name, z_in) {
fit_model <- c(list(Z = z_in), model_constants)
fit <- MARSS(gen_mat, model = fit_model,
silent = FALSE, control = list(minit = 100, maxit = 500))
#use BFGS except when equalvarcov (can't fit)
if (fit$convergence != 0){
fit <- MARSS(gen_mat,
model = fit_model,
control = list(maxit=4000, trace=1),
inits = as.matrix(coef(fit)[1]),
method = "BFGS")
}
out <- data.frame(
H = z_name, U = U,
logLik = fit$logLik, AICc = fit$AICc, num.param = fit$num.params,
m = length(unique(z_in)),
num.iter = fit$numIter,
converged = !fit$convergence,
stringsAsFactors = FALSE)
list(fit = fit, out = out)
}
# tibble containing model combinations
mod_names = expand.grid(z = names(z_models)) %>%
mutate(name = paste(z, sep = "-"))
mod_tbl <- tibble(
mod_name = mod_names$name,
z_name = mod_names$z,
z_models = rep(z_models, each = length(unique(q_models)))
)
mod_tbl <- tibble(
mod_name = mod_names$name,
z_name = mod_names$z,
z_models = z_models)
mod_tbl
# fit generic MARSS models
marss_list <- furrr::future_pmap(list(z_name = mod_tbl$z_name,
z_in = mod_tbl$z_models),
.f = fit_marss,
.progress = TRUE)
marss_aic_tab <- purrr::map(marss_list, "out") %>%
bind_rows() %>%
arrange(AICc) %>%
mutate(deltaAICc = AICc - min(AICc),
rel_like = exp(-1 * deltaAICc / 2),
aic_weight = rel_like / sum(rel_like))
marss_aic_tab
mod_tbl
marss_list
# fit generic MARSS models
marss_list <- furrr::future_pmap(list(z_name = mod_tbl$z_name,
z_in = mod_tbl$z_models),
.f = fit_marss,
.progress = TRUE)
A <- "zero"
Q <- 'unconstrained'
model_constants <- list(U = U, B = B, x0 = x0, A = A, V0 = V0, Q = Q)
# function to fit models
fit_marss <- function(z_name, z_in) {
fit_model <- c(list(Z = z_in), model_constants)
fit <- MARSS(gen_mat, model = fit_model,
silent = FALSE, control = list(minit = 100, maxit = 500))
#use BFGS except when equalvarcov (can't fit)
if (fit$convergence != 0){
fit <- MARSS(gen_mat,
model = fit_model,
control = list(maxit=4000, trace=1),
inits = as.matrix(coef(fit)[1]),
method = "BFGS")
}
out <- data.frame(
H = z_name, U = U,
logLik = fit$logLik, AICc = fit$AICc, num.param = fit$num.params,
m = length(unique(z_in)),
num.iter = fit$numIter,
converged = !fit$convergence,
stringsAsFactors = FALSE)
list(fit = fit, out = out)
}
# tibble containing model combinations
mod_names = expand.grid(z = names(z_models)) %>%
mutate(name = paste(z, sep = "-"))
mod_tbl <- tibble(
mod_name = mod_names$name,
z_name = mod_names$z,
z_models = z_models
)
# fit generic MARSS models
marss_list <- furrr::future_pmap(list(z_name = mod_tbl$z_name,
z_in = mod_tbl$z_models),
.f = fit_marss,
.progress = TRUE)
marss_aic_tab <- purrr::map(marss_list, "out") %>%
bind_rows() %>%
arrange(AICc) %>%
mutate(deltaAICc = AICc - min(AICc),
rel_like = exp(-1 * deltaAICc / 2),
aic_weight = rel_like / sum(rel_like))
marss_aic_tab
marss_aic_tab <- purrr::map(marss_list, "out") %>%
bind_rows() %>%
arrange(AICc) %>%
mutate(deltaAICc = AICc - min(AICc),
rel_like = exp(-1 * deltaAICc / 2),
aic_weight = rel_like / sum(rel_like))
saveRDS(marss_aic_tab, here::here("data", "generation_fits",
"marss_aic_tab_zeroA_centered.RDS"))
# make matrix
gen_mat1 <- gen %>%
select(year, stock, gen_length) %>%
pivot_wider(names_from = stock, values_from = gen_length) %>%
arrange(year) %>%
as.matrix() %>%
t()
gen_mat <- gen_mat1[2:nrow(gen_mat1), ]
colnames(gen_mat) <- seq(min(gen$year), max(gen$year), by = 1)
n_ts <- nrow(gen_mat)
tt <- ncol(gen_mat)
## Generic MARSS approach (model selection)
# specify the z models based on different groupings (smolt, run, a dist, j dist)
z_model_inputs <- colnames(gen)[which(colnames(gen) %in% c("smolt", "run") |
str_detect(colnames(gen), "group"))]
z_models <- map(z_model_inputs, function (x) {
stk_tbl %>%
pull(.data[[x]]) %>%
factor()
})
names(z_models) <- z_model_inputs
# q_models <- c("diagonal and unequal", "unconstrained")
# a_models <- c("scaling", "zero")
U <- "unequal"
R <- "diagonal and unequal"
A <- "zero"
B <- "identity"
x0 <- "unequal"
V0 <- "zero"
Q <- 'unconstrained'
model_constants <- list(U = U, B = B, x0 = x0, A = A, V0 = V0, Q = Q)
A <- "scaling"
B <- "identity"
x0 <- "unequal"
V0 <- "zero"
Q <- 'unconstrained'
model_constants <- list(U = U, B = B, x0 = x0, A = A, V0 = V0, Q = Q)
# function to fit models
fit_marss <- function(z_name, z_in) {
fit_model <- c(list(Z = z_in), model_constants)
fit <- MARSS(gen_mat, model = fit_model,
silent = FALSE, control = list(minit = 100, maxit = 500))
#use BFGS except when equalvarcov (can't fit)
if (fit$convergence != 0){
fit <- MARSS(gen_mat,
model = fit_model,
control = list(maxit=4000, trace=1),
inits = as.matrix(coef(fit)[1]),
method = "BFGS")
}
out <- data.frame(
H = z_name, U = U,
logLik = fit$logLik, AICc = fit$AICc, num.param = fit$num.params,
m = length(unique(z_in)),
num.iter = fit$numIter,
converged = !fit$convergence,
stringsAsFactors = FALSE)
list(fit = fit, out = out)
}
# tibble containing model combinations
mod_names = expand.grid(z = names(z_models)) %>%
mutate(name = paste(z, sep = "-"))
mod_tbl <- tibble(
mod_name = mod_names$name,
z_name = mod_names$z,
z_models = z_models
)
# fit generic MARSS models
marss_list <- furrr::future_pmap(list(z_name = mod_tbl$z_name,
z_in = mod_tbl$z_models),
.f = fit_marss,
.progress = TRUE)
marss_aic_tab <- purrr::map(marss_list, "out") %>%
bind_rows() %>%
arrange(AICc) %>%
mutate(deltaAICc = AICc - min(AICc),
rel_like = exp(-1 * deltaAICc / 2),
aic_weight = rel_like / sum(rel_like))
marss_aic_tab
saveRDS(marss_aic_tab, here::here("data", "generation_fits",
"marss_aic_tab_scalingA_raw.RDS"))
marss_aic_tab1 <- readRDS(here::here("data", "generation_fits",
"marss_aic_tab_scalingA_centered.RDS"))
marss_aic_tab2 <- readRDS(here::here("data", "generation_fits",
"marss_aic_tab_zeroA_centered.RDS"))
marss_aic_tab3 <- readRDS(here::here("data", "generation_fits",
"marss_aic_tab_scalingA_raw.RDS"))
marss_aic_tab1
library(MARSS)
library(tidyverse)
ncores <- parallel::detectCores()
future::plan(future::multisession, workers = ncores - 2)
surv <- readRDS(here::here("data/salmonData/cwt_indicator_surv_clean.RDS")) %>%
#remove stocks that are aggregates of others on CP's advice
# TST combines STI/TAK and AKS combines SSA and NSA
filter(!stock %in% c("TST", "AKS"),
year < 2017) %>%
group_by(stock) %>%
mutate(M_z = as.numeric(scale(M)),
M_cent = as.numeric(scale(M, center = TRUE, scale = FALSE))) %>%
ungroup() %>%
droplevels()
# dataframe of only stocks and juvenile groupings
stk_tbl <- surv %>%
ungroup() %>%
select(stock, stock_name, smolt, run,
j_group1:j_group4, a_group1:a_group4, j_group4b:j_group1b) %>%
distinct()
# make matrix of natural mortality rates
m_mat <- surv %>%
select(year, stock, M) %>%
pivot_wider(names_from = stock, values_from = M) %>%
arrange(year) %>%
as.matrix() %>%
t()
m_mat <- m_mat[2:nrow(m_mat), ]
colnames(m_mat) <- seq(min(surv$year), max(surv$year), by = 1)
n_ts <- nrow(m_mat)
tt <- ncol(m_mat)
## Generic MARSS approach
# specify the z models based on different groupings (smolt, run, a dist, j dist)
z_model_inputs <- colnames(surv)[which(colnames(surv) %in% c("smolt", "run") |
str_detect(colnames(surv), "group"))]
z_models <- map(z_model_inputs, function (x) {
stk_tbl %>%
pull(.data[[x]]) %>%
factor()
})
names(z_models) <- z_model_inputs
U <- "unequal"
R <- "diagonal and unequal"
A <- "scaling" #c("scaling", "zero")
B <- "identity"
x0 <- "unequal"
V0 <- "zero"
Q <- "unconstrained"
model_constants <- list(U = U, B = B, x0 = x0, V0 = V0, Q = Q)
# function to fit models
fit_marss <- function(z_name, z_in) {
fit_model <- c(list(Z = z_in), model_constants)
fit <- MARSS(m_mat, model = fit_model,
silent = FALSE,
control = list(minit = 100, maxit = 500, safe = TRUE))
if (fit$convergence != 0){
fit <- MARSS(m_mat,
model = fit_model,
control = list(maxit = 4000, trace = 1),
inits = as.matrix(coef(fit)[1]),
method = "BFGS")
}
out <- data.frame(
H = z_name, U = U,
logLik = fit$logLik, AICc = fit$AICc, num.param = fit$num.params,
m = length(unique(z_in)),
num.iter = fit$numIter,
converged = !fit$convergence,
stringsAsFactors = FALSE)
list(fit = fit, out = out)
}
# tibble containing model combinations
mod_names = expand.grid(q = q_models,
z = names(z_models)) %>%
mutate(name = paste(z, q, sep = "-"))
mod_tbl <- tibble(
mod_name = mod_names$name,
z_name = mod_names$z,
z_models = z_models
)
# tibble containing model combinations
mod_names = expand.grid(z = names(z_models)) %>%
mutate(name = paste(z, q, sep = "-"))
# tibble containing model combinations
mod_names = expand.grid(z = names(z_models)) %>%
mutate(name = paste(z, sep = "-"))
mod_names
mod_tbl <- tibble(
mod_name = mod_names$name,
z_name = mod_names$z,
z_models = z_models
)
mod_tbl
# fit generic MARSS models
marss_list <- furrr::future_pmap(list(z_name = mod_tbl$z_name,
z_in = mod_tbl$z_models),
.f = fit_marss,
a_in = "zero",
.progress = TRUE)
# fit generic MARSS models
marss_list <- furrr::future_pmap(list(z_name = mod_tbl$z_name,
z_in = mod_tbl$z_models),
.f = fit_marss,
.progress = TRUE)
marss_aic_tab <- purrr::map(marss_list, "out") %>%
bind_rows() %>%
arrange(AICc) %>%
mutate(deltaAICc = AICc - min(AICc),
rel_like = exp(-1 * deltaAICc / 2),
aic_weight = rel_like / sum(rel_like))
marss_aic_tab <- purrr::map(marss_list, "out") %>%
bind_rows() %>%
arrange(AICc) %>%
mutate(deltaAICc = AICc - min(AICc),
rel_like = exp(-1 * deltaAICc / 2),
aic_weight = rel_like / sum(rel_like))
marss_aic_tab
saveRDS(marss_aic_tab, here::here("data", "mortality_fits",
"marss_aic_tab.RDS"))
