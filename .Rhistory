stks = stkID,
names = namesIn[x]))
modOutCI2 <- do.call(rbind, dum2) %>%
spread(key = estimate, value = value) %>%
inner_join(byDatTrim %>% select(stock, region), by = "stock") %>%
distinct() %>%
mutate(stock = as.factor(stock)) %>%
arrange(region) %>%
filter(year > 1985)
ggplot(modOutCI2) +
geom_line(aes(x = year, y = ex)) +
geom_point(aes(x = modOutCI$year, y = modOutCI$y,
colour = modOutCI$region)) +
geom_ribbon(aes(x = year, ymin = lo, ymax = up), linetype = 2,
alpha = 0.2) +
facet_wrap(~stock)
modOutCI2 <- do.call(rbind, dum2) %>%
spread(key = estimate, value = value) %>%
inner_join(byDatTrim %>% select(stock, region), by = "stock") %>%
distinct() %>%
mutate(stock = as.factor(stock)) %>%
arrange(region)
head(modOutCI2)
tail(modOutCI2)
head(modOutCI)
dim(modOutCI)
dim(modOutCI2)
ggplot(modOutCI2) +
geom_line(aes(x = year, y = ex)) +
geom_point(aes(x = modOutCI$year, y = modOutCI$y,
colour = modOutCI$region))
ggplot(modOutCI2) +
geom_line(aes(x = year, y = ex)) +
geom_point(aes(x = modOutCI$year, y = modOutCI$y,
colour = modOutCI$region)) +
geom_ribbon(aes(x = year, ymin = lo, ymax = up), linetype = 2,
alpha = 0.2)
ggplot(modOutCI2) +
geom_line(aes(x = year, y = ex)) +
geom_point(aes(x = modOutCI$year, y = modOutCI$y,
colour = modOutCI$region)) +
geom_ribbon(aes(x = year, ymin = lo, ymax = up), linetype = 2,
alpha = 0.2) +
facet_wrap(~stock)
mod1
inMList <- list(1, 2, 3, 4, 5, 6, 7)
subDir <- "salishSeaOnly_short" #for data cropped at 1985
inRSeq <- c("diagonal and unequal", "equalvarcov")
for (i in seq_along(inRSeq)) {
inRDum <- inRSeq[i]
Ncores <- detectCores()
cl <- makeCluster(Ncores - 2) #save two cores
registerDoParallel(cl)
clusterEvalQ(cl, c(library(MARSS), library(here), library(Rcpp),
library(RcppArmadillo)))
clusterExport(cl, c("byMatZ", "inMList", "fitDFA", "subDir"),
envir=environment())
tic("run in parallel")
parLapply(cl, inMList, function(x) {
fitDFA(byMatZ, inR = inRDum, inM = x, maxIteration = 1000,
subDirName = subDir)
})
stopCluster(cl) #end cluster
toc()
}
inRSeq <- c("diagonal and unequal", "equalvarcov")
for (i in seq_along(inRSeq)) {
inRDum <- inRSeq[i]
Ncores <- detectCores()
cl <- makeCluster(Ncores - 2) #save two cores
registerDoParallel(cl)
clusterEvalQ(cl, c(library(MARSS), library(here), library(Rcpp),
library(RcppArmadillo)))
clusterExport(cl, c("byMatZ", "inMList", "fitDFA", "subDir"),
envir=environment())
tic("run in parallel")
parLapply(cl, inMList, function(x) {
fitDFA(byMatZ, inR = inRDum, inM = x, maxIteration = 1000,
subDirName = subDir)
})
stopCluster(cl) #end cluster
toc()
}
for (i in seq_along(inRSeq)) {
inRDum <- inRSeq[i]
Ncores <- detectCores()
cl <- makeCluster(Ncores - 2) #save two cores
registerDoParallel(cl)
clusterEvalQ(cl, c(library(MARSS), library(here), library(Rcpp),
library(RcppArmadillo)))
clusterExport(cl, c("byMatZ", "inMList", "fitDFA", "subDir", "inRDum"),
envir=environment())
tic("run in parallel")
parLapply(cl, inMList, function(x) {
fitDFA(byMatZ, inR = inRDum, inM = x, maxIteration = 1000,
subDirName = subDir)
})
stopCluster(cl) #end cluster
toc()
}
source('C:/github/chinDyn/R/functions/dfaFunctions.R')
dfaSummary <- getTopDFA(subDir)
dfaSummary[[2]] #prints AIC table
mod1 <- dfaSummary[[1]]
estZ <- coef(mod1, type = "matrix")$Z
#retrieve rotated matrix
invH <- if (ncol(estZ) > 1) {
varimax(estZ)$rotmat
} else if (ncol(estZ) == 1) {
1
}
## Factor loadings
#rotate factor loadings
rotZ <- rotateLoadings(zIn = estZ, H = invH, stkNames = stkID,
survDat = byDatTrim)
ggplot(rotZ, aes(x = stock, y = loading, fill = region)) +
geom_col() +
theme_sleekX(axisSize = 9, legendSize = 0.7) +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
facet_wrap(~trend)
rotTrends <- rotateTrends(modIn = mod1, H = invH)
ggplot(rotTrends, aes(x = year, y = est)) +
geom_line() +
theme_sleekX() +
geom_hline(yintercept = 0, colour = "red") +
facet_wrap(~trend)
modOutCI <- broom::augment(mod1, interval = "confidence") %>%
dplyr::rename(stock = .rownames) %>%
inner_join(byDatTrim %>% select(stock, region), by = "stock") %>%
distinct() %>%
mutate(year = t + 1984, #add so that year is correct
stock = as.factor(stock)) %>%
arrange(region)
ggplot(modOutCI) +
geom_line(aes(x = year, y = .fitted)) +
geom_point(aes(x = year, y = y, colour = region)) +
geom_ribbon(aes(x = year, ymin = .conf.low, ymax = .conf.up), linetype = 2,
alpha = 0.2) +
facet_wrap(~stock)
modOutCI <- broom::augment(mod1, interval = "confidence") %>%
dplyr::rename(stock = .rownames) %>%
inner_join(byDatTrim %>% select(stock, region), by = "stock") %>%
distinct() %>%
arrange(region) %>%
mutate(year = t + 1984, #add so that year is correct
stock = factor(stock, unique(stock)))
ggplot(modOutCI) +
geom_line(aes(x = year, y = .fitted)) +
geom_point(aes(x = year, y = y, colour = region)) +
geom_ribbon(aes(x = year, ymin = .conf.low, ymax = .conf.up), linetype = 2,
alpha = 0.2) +
facet_wrap(~stock)
ggplot(modOutCI) +
geom_line(aes(x = year, y = .fitted)) +
geom_point(aes(x = year, y = y, colour = region)) +
geom_ribbon(aes(x = year, ymin = .conf.low, ymax = .conf.up), linetype = 2,
alpha = 0.2) +
facet_wrap(~stock)
dum <- get_DFA_fits(mod1)
namesIn <- names(dum)
dum2 <- lapply(seq_along(dum), function (x) gatherList(dum[[x]], yrs = broodYrs,
stks = stkID,
names = namesIn[x]))
modOutCI2 <- do.call(rbind, dum2) %>%
spread(key = estimate, value = value) %>%
inner_join(byDatTrim %>% select(stock, region), by = "stock") %>%
distinct() %>%
arrange(region) %>%
mutate(stock = factor(stock, unique(stock))) %>%
filter(year > 1985)
ggplot(modOutCI2) +
geom_line(aes(x = year, y = ex)) +
geom_point(aes(x = modOutCI$year, y = modOutCI$y,
colour = modOutCI$region)) +
geom_ribbon(aes(x = year, ymin = lo, ymax = up), linetype = 2,
alpha = 0.2) +
facet_wrap(~stock)
mod1
dim(modOutCI)
dim(modOutCI2)
modOutCI2 <- do.call(rbind, dum2) %>%
spread(key = estimate, value = value) %>%
inner_join(byDatTrim %>% select(stock, region), by = "stock") %>%
distinct() %>%
arrange(region) %>%
mutate(stock = factor(stock, unique(stock))) %>%
filter(year > 1985)
modOutCI2 <- do.call(rbind, dum2) %>%
)
dim(modOutCI)
dim(modOutCI2)
ggplot(modOutCI2) +
geom_line(aes(x = year, y = ex)) +
# geom_point(aes(x = modOutCI$year, y = modOutCI$y,
#                colour = modOutCI$region)) +
geom_ribbon(aes(x = year, ymin = lo, ymax = up), linetype = 2,
alpha = 0.2) +
facet_wrap(~stock)
dim(dum)
dum <- get_DFA_fits(mod1)
namesIn <- names(dum)
dum2 <- lapply(seq_along(dum), function (x) gatherList(dum[[x]], yrs = broodYrs,
stks = stkID,
names = namesIn[x]))
str(dum2)
str(modOutCI)
modOutCI2 <- do.call(rbind, dum2) %>%
spread(key = estimate, value = value) %>%
inner_join(byDatTrim %>% select(stock, region), by = "stock") %>%
distinct() %>%
arrange(region) %>%
mutate(stock = factor(stock, unique(stock))) %>%
filter(year > 1984)
ggplot(modOutCI2) +
geom_line(aes(x = year, y = ex)) +
# geom_point(aes(x = modOutCI$year, y = modOutCI$y,
#                colour = modOutCI$region)) +
geom_ribbon(aes(x = year, ymin = lo, ymax = up), linetype = 2,
alpha = 0.2) +
facet_wrap(~stock)
ggplot(modOutCI2) +
geom_line(aes(x = year, y = ex)) +
geom_point(aes(x = modOutCI$year, y = modOutCI$y,
colour = modOutCI$region)) +
geom_ribbon(aes(x = year, ymin = lo, ymax = up), linetype = 2,
alpha = 0.2) +
facet_wrap(~stock)
head(modOutCI2)
head(modOutCI)
modOutCI2 <- do.call(rbind, dum2) %>%
spread(key = estimate, value = value) %>%
inner_join(byDatTrim %>% select(stock, region), by = "stock") %>%
inner_join(modOutCI %>% select(y, stock, year), by = c("stock", "year")) %>%
distinct() %>%
arrange(region) %>%
mutate(stock = factor(stock, unique(stock))) %>%
filter(year > 1984)
head(modOutCI2)
ggplot(modOutCI2) +
geom_line(aes(x = year, y = ex)) +
geom_point(aes(x = year, y = y, colour = region)) +
geom_ribbon(aes(x = year, ymin = lo, ymax = up), linetype = 2,
alpha = 0.2) +
facet_wrap(~stock)
head(rotZ)
head(byDatZ)
head(byDatTrim)
## Factor loadings
#rotate factor loadings
rotZ <- rotateLoadings(zIn = estZ, H = invH, stkNames = stkID,
survDat = byDatTrim) %>%
inner_join(byDatTrim %>% select(stock, smoltType, adultRunTiming),
by = "stock")
ggplot(rotZ, aes(x = stock, y = loading, fill = smoltType)) +
geom_col() +
theme_sleekX(axisSize = 9, legendSize = 0.7) +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
facet_wrap(~trend)
ggplot(rotZ, aes(x = stock, y = loading, fill = adultRunTiming)) +
geom_col() +
theme_sleekX(axisSize = 9, legendSize = 0.7) +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
facet_wrap(~trend)
eyDat <- read.csv(here("data/salmonData/CLEANcwtInd_age2SR_OEY.csv"),
stringsAsFactors = FALSE)
eyDatTrim <- eyDat %>%
filter(region %in% c("LFR", "MFR", "UFR", "ECVI", "SPGSD", "NPGSD"))%>%
group_by(stock) %>%
mutate(survZ = as.numeric(scale(surv))) %>%
ungroup(stock) %>%
arrange(region) %>%
mutate(stock = factor(stock, unique(stock))) %>%
select(-stockName, -jurisdiction, -lat, -long)
range(eyDatTrim$OEY)
range(byDat$BY)
byMatZ <- byDatTrim %>%
select(BY, stock, survZ) %>%
spread(key = stock, value = survZ) %>%
select(-BY) %>%
as.matrix() %>%
t()
eyMatZ <- byDatTrim %>%
select(OEY, stock, survZ) %>%
spread(key = stock, value = survZ) %>%
select(-OEY) %>%
as.matrix() %>%
t()
eyMatZ <- eyDatTrim %>%
select(OEY, stock, survZ) %>%
spread(key = stock, value = survZ) %>%
select(-OEY) %>%
as.matrix() %>%
t()
entryYrs <- unique(eyDatTrim$OEY)
colnames(eyMatZ) <- broodYrs
nStks <- nrow(eyMatZ)
colnames(eyMatZ) <- entryYears
entryYrs <- unique(eyDatTrim$OEY)
colnames(eyMatZ) <- entryYrs
nStks <- nrow(eyMatZ)
stkID <- rownames(eyMatZ)
nYrs <- ncol(eyMatZ)
head(eyDatTrim)
ggplot(eyDatTrim, aes(x = OEY, y = survZ, colour = region)) %>%
geom_poit() +
samSim::theme_sleekX() +
facet_wrap(~stock)
ggplot(eyDatTrim, aes(x = OEY, y = survZ, colour = region)) %>%
geom_point() +
samSim::theme_sleekX() +
facet_wrap(~stock)
head(eyDatTrim)
ggplot(eyDatTrim, aes(x = OEY, y = survZ, colour = region)) +
geom_point() +
samSim::theme_sleekX() +
facet_wrap(~stock)
?scale
eyDatTrim <- eyDat %>%
filter(region %in% c("LFR", "MFR", "UFR", "ECVI", "SPGSD", "NPGSD"))%>%
group_by(stock) %>%
mutate(survZ = as.numeric(scale(surv, center = TRUE, scale = TRUE))) %>%
ungroup(stock) %>%
arrange(region) %>%
mutate(stock = factor(stock, unique(stock))) %>%
select(-stockName, -jurisdiction, -lat, -long)
ggplot(eyDatTrim, aes(x = OEY, y = survZ, colour = region)) +
geom_point() +
samSim::theme_sleekX() +
facet_wrap(~stock)
ggplot(byDatTrim, aes(x = OEY, y = survZ, colour = region)) +
geom_point() +
samSim::theme_sleekX() +
facet_wrap(~stock)
ggplot(byDatTrim, aes(x = BY, y = survZ, colour = region)) +
geom_point() +
samSim::theme_sleekX() +
facet_wrap(~stock)
byDatTrim %>%
group_by(stock) %>%
summarize(mean(survZ))
byDatTrim %>%
group_by(stock) %>%
summarize(mean(survZ, na.rm = TRUE))
#focus on subset of BC pops for initial analyses
byDatTrim <- byDat %>%
filter(region %in% c("LFR", "MFR", "UFR", "ECVI", "SPGSD", "NPGSD"),
BY > 1984) %>%
group_by(stock) %>%
mutate(survZ = as.numeric(scale(surv))) %>%
ungroup(stock) %>%
arrange(region) %>%
mutate(stock = factor(stock, unique(stock))) %>%
select(-stockName, -jurisdiction, -lat, -long)
byDatTrim %>%
group_by(stock) %>%
summarize(mean(survZ, na.rm = TRUE))
byMatZ <- byDatTrim %>%
select(BY, stock, survZ) %>%
spread(key = stock, value = survZ) %>%
select(-BY) %>%
as.matrix() %>%
t()
broodYrs <- unique(byDatTrim$BY)
colnames(byMatZ) <- broodYrs
nStks <- nrow(byMatZ)
nYrs <- ncol(byMatZ)
stkID <- rownames(byMatZ)
inMList <- list(1, 2, 3, 4, 5, 6, 7)
subDir <- "salishSeaOnly_short" #for data cropped at 1985
inRSeq <- c("diagonal and unequal", "equalvarcov")
for (i in seq_along(inRSeq)) {
inRDum <- inRSeq[i]
Ncores <- detectCores()
cl <- makeCluster(Ncores - 2) #save two cores
registerDoParallel(cl)
clusterEvalQ(cl, c(library(MARSS), library(here), library(Rcpp),
library(RcppArmadillo)))
clusterExport(cl, c("byMatZ", "inMList", "fitDFA", "subDir", "inRDum"),
envir=environment())
tic("run in parallel")
parLapply(cl, inMList, function(x) {
fitDFA(byMatZ, inR = inRDum, inM = x, maxIteration = 1000,
subDirName = subDir)
})
stopCluster(cl) #end cluster
toc()
}
dfaSummary <- getTopDFA(subDir)
dfaSummary[[2]] #prints AIC table
mod1 <- dfaSummary[[1]]
estZ <- coef(mod1, type = "matrix")$Z
#retrieve rotated matrix
invH <- if (ncol(estZ) > 1) {
varimax(estZ)$rotmat
} else if (ncol(estZ) == 1) {
1
}
## Factor loadings
#rotate factor loadings
rotZ <- rotateLoadings(zIn = estZ, H = invH, stkNames = stkID,
survDat = byDatTrim) %>%
inner_join(byDatTrim %>% select(stock, smoltType, adultRunTiming),
by = "stock")
ggplot(rotZ, aes(x = stock, y = loading, fill = region)) +
geom_col() +
theme_sleekX(axisSize = 9, legendSize = 0.7) +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
facet_wrap(~trend)
rotTrends <- rotateTrends(modIn = mod1, H = invH)
ggplot(rotTrends, aes(x = year, y = est)) +
geom_line() +
theme_sleekX() +
geom_hline(yintercept = 0, colour = "red") +
facet_wrap(~trend)
modOutCI <- broom::augment(mod1, interval = "confidence") %>%
dplyr::rename(stock = .rownames) %>%
inner_join(byDatTrim %>% select(stock, region), by = "stock") %>%
distinct() %>%
arrange(region) %>%
mutate(year = t + 1984, #add so that year is correct
stock = factor(stock, unique(stock)))
ggplot(modOutCI) +
geom_line(aes(x = year, y = .fitted)) +
geom_point(aes(x = year, y = y, colour = region)) +
geom_ribbon(aes(x = year, ymin = .conf.low, ymax = .conf.up), linetype = 2,
alpha = 0.2) +
facet_wrap(~stock)
eyDat <- read.csv(here("data/salmonData/CLEANcwtInd_age2SR_OEY.csv"),
stringsAsFactors = FALSE)
#focus on subset of BC pops for initial analyses
eyDatTrim <- eyDat %>%
filter(region %in% c("LFR", "MFR", "UFR", "ECVI", "SPGSD", "NPGSD"),
OEY > 1985)%>%
group_by(stock) %>%
mutate(survZ = as.numeric(scale(surv, center = TRUE, scale = TRUE))) %>%
ungroup(stock) %>%
arrange(region) %>%
mutate(stock = factor(stock, unique(stock))) %>%
select(-stockName, -jurisdiction, -lat, -long)
ggplot(eyDatTrim, aes(x = OEY, y = survZ, colour = region)) +
geom_point() +
samSim::theme_sleekX() +
facet_wrap(~stock)
eyDatTrim %>% group_by(stock) %>% summarize(mean(survZ))
eyDatTrim %>% group_by(stock) %>% summarize(mean(survZ, na.rm = TRUE))
eyMatZ <- eyDatTrim %>%
select(OEY, stock, survZ) %>%
spread(key = stock, value = survZ) %>%
select(-OEY) %>%
as.matrix() %>%
t()
entryYrs <- unique(eyDatTrim$OEY)
colnames(eyMatZ) <- entryYrs
nStks <- nrow(eyMatZ)
nYrs <- ncol(eyMatZ)
stkID <- rownames(eyMatZ)
inMList <- list(1, 2, 3, 4, 5, 6, 7)
subDir <- "salishSeaOnly_short_OEY"
inRSeq <- c("diagonal and unequal", "equalvarcov")
for (i in seq_along(inRSeq)) {
inRDum <- inRSeq[i]
Ncores <- detectCores()
cl <- makeCluster(Ncores - 2) #save two cores
registerDoParallel(cl)
clusterEvalQ(cl, c(library(MARSS), library(here), library(Rcpp),
library(RcppArmadillo)))
clusterExport(cl, c("byMatZ", "inMList", "fitDFA", "subDir", "inRDum"),
envir=environment())
tic("run in parallel")
parLapply(cl, inMList, function(x) {
fitDFA(byMatZ, inR = inRDum, inM = x, maxIteration = 1000,
subDirName = subDir)
})
stopCluster(cl) #end cluster
toc()
}
dfaSummaryEY <- getTopDFA(subDir)
dfaSummaryEY[[2]] #prints AIC table
estZ <- coef(modEY, type = "matrix")$Z
modEY <- dfaSummary[[1]]
estZ <- coef(modEY, type = "matrix")$Z
#retrieve rotated matrix
invH <- if (ncol(estZ) > 1) {
varimax(estZ)$rotmat
} else if (ncol(estZ) == 1) {
1
}
## Factor loadings
#rotate factor loadings
rotZ <- rotateLoadings(zIn = estZ, H = invH, stkNames = stkID,
survDat = byDatTrim) %>%
inner_join(byDatTrim %>% select(stock, smoltType, adultRunTiming),
by = "stock")
ggplot(rotZ, aes(x = stock, y = loading, fill = region)) +
geom_col() +
theme_sleekX(axisSize = 9, legendSize = 0.7) +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
facet_wrap(~trend)
head(rotZ)
## Factor loadings
#rotate factor loadings
rotZ <- rotateLoadings(zIn = estZ, H = invH, stkNames = stkID,
survDat = byDatTrim) %>%
inner_join(byDatTrim %>% select(stock, smoltType, adultRunTiming),
by = "stock") %>%
distinct()
#No coherent patterns associated with adult run timing
ggplot(rotZ, aes(x = stock, y = loading, fill = smoltType)) +
geom_col() +
theme_sleekX(axisSize = 9, legendSize = 0.7) +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
facet_wrap(~trend)
