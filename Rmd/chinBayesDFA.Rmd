---
title: "Bayesian Chinook DFA"
author: "Cam Freshwater"
date: "May 9, 2019"
output: html_document
---

After preliminary runs with chinook data noticed issues with estimating states for early portion of time series. Specifically the lack of data for certain time series mean that the estimated states were predicting (potentially) unreasonably high historical survival (these data are saved in `data/dfaFits/salishSeaOnly`). 

The `shortSalishSeaDFA.Rmd` provides one means of resolving this issue, by cropping the data. Here we use a Bayesian DFA, which is better able to estimate uncertainty in gappy time series, as an alternative means of exploring patterns in the data. Additonally the Bayesian DFA models can account for student-t process variance distributions and explicit tests for different regimes (e.g. 1970s vs. now).

First analysis will focus, as before, on Salish Sea only stocks so that these results can be compared to the ML models. Second analysis will include a broader range of stocks.

```{r loadAndClean}
listOfPackages <- c("here", "bayesdfa", "tidyverse", "ggplot2", "parallel", 
                    "doParallel", "foreach", "tictoc")
lapply(listOfPackages, require, character.only = TRUE)

#helper functions to fit and post-process DFA
source(here("R/functions/dfaFunctions.R"))

eyDat <- read.csv(here("data/salmonData/CLEANcwtInd_age2SR_OEY.csv"), 
                  stringsAsFactors = FALSE)

#focus on subset of BC pops for initial analyses
eyDatTrim <- eyDat %>% 
  filter(region %in% c("LFR", "MFR", "UFR", "ECVI", "SPGSD", "NPGSD")) %>% 
  group_by(stock) %>% 
  # mutate(survZ = as.numeric(scale(surv))) %>%
  ungroup(stock) %>% 
  arrange(region) %>% 
  mutate(stock = factor(stock, unique(stock))) %>% 
  select(-stockName, -jurisdiction, -lat, -long)

eyMat <- eyDatTrim %>%
  select(OEY, stock, surv) %>%
  spread(key = stock, value = surv) %>%
  select(-OEY) %>% 
  as.matrix() %>% 
  t()
entryYrs <- unique(eyDatTrim$OEY)
colnames(eyMatZ) <- entryYrs

nStks <- nrow(eyMatZ)
nYrs <- ncol(eyMatZ)
stkID <- rownames(eyMatZ)
```

Example below shows a 2 trend model (arbitrarily chosen) with loadings and trends. Notice that the uncertainty estimates are much larger at the beginning of the time series.

```{r bayesDFATestRun}
f1 <- fit_dfa(y = eyMat, num_trends = 2, zscore = TRUE, iter = 1000, chains = 4,
              thin = 1)
is_converged(f1, threshold = 1.05)
r1 <- rotate_trends(f1)
plot_trends(r1)
plot_fitted(f1)
plot_loadings(r1)
```

Run model selection with up to 6 trends, both normal and student-t process variance, and independent or correlated observation error.

```{r bayesDFATestRun}
ttt <- eyMat[1:8, ]
ranges <- data.frame(min = c(1, 4),
                     max = c(3, 6)) %>% 
  split(., seq(nrow(.)))

# for (i in seq_along(inRSeq)) {
  Ncores <- detectCores()
  cl <- makeCluster(Ncores - 2) #save two cores
  registerDoParallel(cl)
  clusterEvalQ(cl, c(library(bayesdfa), library(here), library(Rcpp),
                     library(RcppArmadillo)))
  clusterExport(cl, c("ttt", "find_dfa_trends", "ranges"),
                envir=environment())
  tic("run in parallel")
  dum <- parLapply(cl, ranges, function(x) {
    find_dfa_trends(y = ttt, iter = 250, kmin = x$min, kmax = x$max, 
                    chains = 1, compare_normal = FALSE, zscore = TRUE,
                    variance = c("equal", "unequal"))
  })
  stopCluster(cl) #end cluster
  toc()
# }

  tic("run in parallel")
  find_dfa_trends(y = ttt, iter = 250, kmin = 1, kmax = 6, 
                    chains = 1, compare_normal = FALSE, zscore = TRUE,
                    variance = c("equal", "unequal"))
  toc()
```